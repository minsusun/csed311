\documentclass[openright, a4paper]{article}
\usepackage{graphicx}
\usepackage{kotex}
\usepackage{minted}
\usepackage{setspace}
\usepackage{underscore}
\usepackage{caption}
\usepackage[margin=3cm]{geometry}
\newcommand{\code}[1]{\texttt{#1}}
\setminted{
    linenos=true,
    autogobble,
}
\newenvironment{longlisting}{\captionsetup{type=listing}}{}
\captionsetup{labelformat=empty,labelsep=none}

\title{2024학년도 컴퓨터구조 Lab Assignment \#5\\
        Cache}

\author{김도영, 선민수}
\date{2024년 5월 30일}

\onehalfspacing
\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                   Introduction                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
이 과제에서는 Lab Assignment \#4에서 구현했던 파이프라인 CPU에 더해, 주 메모리에 
저장된 값을 임시로 저장하는 캐시를 구현하였다. Lab Assignment \#4까지의 CPU는 
질의를 받으면 한 사이클 내에 해당 메모리의 값을 반환하는, 일종의 '이상화된 
메모리'(Magic memory)를 가정하고 구현되었다. 이번 과제에서는 이러한 이상적 메모리 
모델에서 벗어나, 지연 시간(Latency) 개념을 도입하였다. 즉, 이번 과제에서는 메모리 
접근에 지연 시간이 존재하여 메모리에서 값을 읽어오기까지 CPU의 파이프라인이 
멈춰야 하며, 이는 곧 CPU의 성능 하락으로 이어진다. 이러한 메모리 접근 지연시간을
해결하기 위해 캐시를 도입하고, 다양한 캐시의 구현에 따른 CPU의 성능 변화를 
알아보는 것이 이번 과제의 골자이다.

캐시는 메모리 계층구조(Memory hierachy) 내에서 주 메모리 위, CPU 레지스터 혹은 
상위 계층 캐시 아래에 위치한다. 주 메모리는 용량이 크지만 느리며, CPU 레지스터는 
빠르지만 개수 및 용량이 제한되어 있다. 캐시는 이 둘 사이에 위치하여 최근에 
접근한 값들 또는 이들에 인접한 값들을 미리 저장해두고, CPU의 질의가 있을 
때마다 주 메모리 대신 저장한 값을 전달한다. 캐시는 CPU 레지스터보다는 느리지만 
메모리에 비해서는 월등히 빠르기 때문에, 프로그래머로 하여금 컴퓨터가 용량이 큰 
동시에 빠른, 이상적 주 메모리를 가지고 있는 것 같은 추상화를 제공한다. 

캐시는 그 구현에 따라 직접 사상(Direct-Mapped), 집합 연관 사상(Set-Associative),
완전 연관 사상(Fully-Associative) 캐시로 나눌 수 있다. 직접 사상 캐시는 메모리의
여러 주소가 캐시의 특정 라인에 직접 대응되는 방식의 캐시이다. 이러한 캐시는
구현이 간단하고, 읽기 및 쓰기에 별다른 연산을 요하지 않아 속도가 빠르지만, 
여러 메모리 주소가 캐시의 한 라인에 대응되어 발생하는 충돌(Conflict)의 발생률이
높아 캐시 적중률이 낮아지는 단점이 있다. 집합 연관 사상 캐시는 여러 캐시 라인을
하나의 집합으로 묶어, 특정 메모리 주소에 대한 질의가 들어왔을 때 그 주소에 
해당하는 집합 내 어느 라인에도 데이터를 저장할 수 있도록 만든 캐시이다. 집합
연관 사상 방식은 읽기 및 쓰기 과정에서 집합 내의 각 Way를 탐색해야 하므로
직접 사상 방식에 비해 느리지만, 공간 활용성이 좋아 충돌 발생률이 낮고 캐시 
적중률이 높다는 특징이 있다. 집합 연관 사상 방식에서 더 나아가 집합의 개수를
라인의 개수와 같게 만들어, 쓰기 질의가 들어왔을 때 캐시 내의 아무 라인에나 
데이터를 저장할 수 있게 만든 방식의 캐시를 완전 연관 사상 캐시라 한다. 이번 
과제에서는 직접 사상 및 집합 연관 사상 방식의 캐시를 구현하였다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      Design                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Design}
캐시는 단순히 데이터를 저장하고 출력하는 것 뿐만 아니라, CPU의 질의에 응답하여
요청 블록이 현재 캐시에 존재하는지 확인하고, 만약 요청된 블록이 현재 캐시에 
없다면 메모리에 해당 블록이 포함된 라인을 질의하여 메모리가 이에 응답하기까지
기다리는 등, 현재 상태에 따라 다양한 동작을 수행한다. 따라서, 캐시는 내부 상태를
가지고 입력에 따라 상태가 변화하는 유한 상태 기계(Finite State Machine)으로 
구현되며, 이번 과제에서 구현된 캐시는 3개의 상태를 가진 유한 상태 기계로 
구현되었다.

%% TODO: Write-back, allocate

%% TODO: FSM Diagram
\hfill

{
    \begin{figure}[!h]
        \centering
        \includegraphics[width=\textwidth]{img/diagram.png}
        \caption{캐시 제어를 위한 유한 상태 기계의 설계}
    \end{figure}
}

\hfill

\begin{description}
  \item[IDLE]상태는 CPU의 요청이 있기 전, 혹은 CPU의 요청을 모두 수행한 후의
  유후 상태를 나타낸다. 캐시는 기본적으로 \code{reset} 신호가 \code{1}일 때,
  이 상태로 초기화된다. IDLE 상태에서, CPU가 요청을 전달하고, 캐시에 요청 대상
  블록이 존재하지 않아 메모리에서 해당 블록을 가져와야 하는 경우 다음 상태로
  전이한다. 만약 요청된 주소에 해당하는 라인이 메모리에서 마지막으로 가져온 이후
  수정되었을(Dirty) 경우 WRITE_WAIT 상태로, 수정되지 않았을 경우 READ_WAIT 상태로
  전이한다.

  \item[WRITE_WAIT]상태는 메모리에 쓰기 요청을 전달하였지만, 메모리가 아직 쓰기가
  완료되었고 다음 요청을 받을 수 있다는 신호(\code{is_ready})를 보내지 않아
  메모리 쓰기 작업이 끝날 때까지 대기하는 상태이다. 만약 해당 신호가 
  \code{1} 이라면 다음 사이클에 READ_WAIT 상태로 전이하며, 아니라면 WRITE_WAIT
  상태에 계속 대기한다.

  \item[READ_WAIT]상태는 메모리에 읽기 요청을 전달하였지만, 메모리가 아직 읽기가
  완료되었고 현재 출력이 유효하다는 신호(\code{is_output_valid})를 보내지 않아
  메모리 읽기 작업이 끝날 때까지 대기하는 상태이다. 만약 해당 신호가 \code{1}
  이라면 다음 사이클에 IDLE 상태로 전이하며, 아니라면 READ_WAIT 상태에 계속 
  대기한다.
\end{description}

캐시는 위와 같은 유한 상태 기계의 상태와 메모리, CPU에서 전달되는 신호에 따라
현재 사이클에서 할 일을 결정한다. 예를 들어, IDLE 상태에서 CPU 쓰기 요청이
전달되었는데, 요청된 블록이 현재 캐시에 존재하는 캐시 적중(Cache Hit) 상황에서는
CPU에서 전달된 데이터를 캐시의 해당 블록에 쓰고 해당 블록이 수정되었음을 
표시한다. 유사하게, READ_WAIT 상태에서 메모리가 현재 출력이 유효하다는 신호가
활성화된 경우, 메모리의 데이터 출력을 캐시의 해당 라인에 쓴다.

본 과제에서 구현한 집합 연관 사상 방식 캐시는 강의 교안의 것을 기반으로
구현하였다. 구현된 캐시의 대략적인 구조도는 다음과 같다.

\hfill

%% TODO: SCHEMATIC IMAGE
{
    \begin{figure}[!h]
        \centering
        \includegraphics[width=\textwidth]{img/schematic.png}
        \caption{집합 연관 캐시의 구조도}
    \end{figure}
}

\hfill

이전 과제에서 구현한 파이프라인 CPU는 이상적 메모리를 가정하고 구현되었으며,
따라서 메모리가 모든 요청에 1 사이클만에 응답할 것을 가정하였다. 이번 과제에서는
이와 다르게, 메모리 및 캐시가 요청에 바로 응답하지 못할 수도 있다. 때문에, 
CPU에서는 반드시 캐시의 \code{is_ready}, \code{is_hit}, \code{is_output_valid}
신호를 평가하여 파이프라인을 정지할지 결정하여야 한다. 때문에, CPU는 현재
메모리의 상태에 따라 새로운 정지 신호(Stall Signal)을 생성하여 파이프라인의 이전
스테이지에 전달한다. 만약 이러한 신호가 \code{1}인 경우, 캐시가 현재 요청을 모두
처리하고 정지 신호가 다시 \code{0}이 될 때까지 CPU는 대기한다.

\hfill

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                 Implementation                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}

CPU module의 구현은 Lab Assignment \#4까지 구현한 것과 (Design 단락에서 설명한 
부분을 제외하면) 대동소이하며, 따라서 이 보고서에서는 캐시의 구현에 집중하여
설명한다.

\subsection{캐시 상태 전이}

\hfill

\begin{longlisting}
    \begin{minted}[fontsize=\footnotesize]{Verilog}
  always @(*) begin
    case(state)
    `IDLE: begin
      if (is_input_valid && !is_hit)
        next_state = dirty[index][write_way_index] ? `WRITE_WAIT : `READ_WAIT;
      else
        next_state = `IDLE;
    end
    `WRITE_WAIT: next_state = is_dmem_ready ? `READ_WAIT : `WRITE_WAIT;
    `READ_WAIT: next_state = is_dmem_output_valid ? `IDLE : `READ_WAIT;
    default: next_state = `IDLE;
    endcase
  end
    \end{minted}
    \caption{캐시의 다음 상태를 계산하는 조합 논리 회로}
\end{longlisting}

\hfill

캐시의 내부 상태는 위와 같이 IDLE로 초기화되어, CPU의 요청 및 캐시 적중 
여부, 쓰고자 하는 라인의 수정 여부, 메모리의 출력 신호에 따라 WRITE_WAIT,
READ_WAIT 상태로 전이한다.  

\subsection{적중된 Way의 인덱스, 쓰기 인덱스의 계산}

\hfill

\begin{longlisting}
    \begin{minted}[fontsize=\footnotesize]{Verilog}
  // Logic that finds the index of the way that hit
  always @(*) begin
    // Notice that hit_way_index may cause unexpected behaviour when used
    // without testing hit_way_found. Usually you may want to examine is_hit,
    // which essencially is just an alias for hit_way_found, before using
    // hit_way_index.
    hit_way_found = 0;
    hit_way_index = 0;

    for (i = 0; i < NUM_WAYS; i = i + 1) begin
      if (tag == tag_bank[index][i] && valid[index][i]) begin
        hit_way_index = i[WAY_INDEX_LEN - 1: 0]; 
        hit_way_found = 1;
      end   
    end
  end
  
  ...

  // Logic that finds the index of the way to write on
  always @(*) begin
    write_way_found = 0;
    write_way_index = 0;

    for (i = 0; i < NUM_WAYS; i = i + 1) begin
      if (!valid[index][i]) begin
        write_way_index = i[WAY_INDEX_LEN - 1: 0];
        write_way_found = 1;
      end
    end

    if (!write_way_found)
      write_way_index = lru;
  end
    \end{minted}
    \caption{적중된 Way의 인덱스, 쓰기 인덱스를 계산하는 조합 논리 회로}
\end{longlisting}

\hfill

캐시 내에서 \code{hit_way_index}, \code{write_way_index}는 캐시 적중 상황에서
적중한 Way의 인덱스, 캐시 쓰기 요청이 들어오거나 메모리 라인을 캐시에 써야 하는
상황에서 쓰기 대상이 될 Way의 인덱스를 저장하는 레지스터이다. 위 논리 회로는 
기본적으로 캐시의 각 Way를 순회하여, 만약 적중 조건을 만족하는 Way를 찾았을 경우
해당 Way의 인덱스를 \code{hit_way_index}에 저장한다. \code{write_way_index} 또한
비슷하게 캐시의 각 Way를 순회하며 유효하지 않은(\code{!valid}) Way를 먼저 찾는다.
만약 그러한 Way가 없다면, 접근된 지 가장 오랜 시간이 지난(Least Recently Used) 
Way를 찾아 해당 Way의 인덱스를 \code{hit_way_index}에 저장한다.

이때 주의할 점은 \code{hit_way_index}는 만약 적중된 Way를 찾지 못하였을 경우
\code{0}을 저장하며, 이 때문에 캐시 부적중(Cache Miss) 상황에서는 이 \code{0}이
그대로 데이터를 가져오는 인덱스로 사용되어 캐시가 예상치 못한 동작(Unexpected
Behaviour)을 보일 수 있다는 점이다. 따라서, \code{hit_way_index}는 반드시 
\code{hit_way_found}, 혹은 이와 동일한 값을 갖는 별칭인 \code{is_hit}을 테스트한
후에 사용되어야 한다.

\subsection{캐시 쓰기 논리 회로}

\hfill

\begin{longlisting}
    \begin{minted}[fontsize=\footnotesize]{Verilog}

    ...

    end else begin
      state <= next_state;

      if (state == `IDLE && is_input_valid && is_hit && mem_rw) begin
        data_bank[index][hit_way_index][32 * offset +: 32] <= din;
        dirty[index][hit_way_index] <= 1;
      end 
      
      if (state == `READ_WAIT && is_dmem_output_valid) begin
        valid[index][write_way_index] <= 1;
        dirty[index][write_way_index] <= 0;
        tag_bank[index][write_way_index] <= tag;
        data_bank[index][write_way_index] <= dmem_dout;
      end

      ...

    end
    \end{minted}
    \caption{캐시의 태그, 데이터를 업데이트하는 순차 논리 회로}
\end{longlisting}

\hfill

CPU에서 캐시에 쓰기 요청을 보내거나, 메모리에서 읽기 요청에 대한 응답이
도착하였다면 캐시의 태그 저장소(Tag Bank), 데이터 저장소(Data Bank)에 해당 
데이터를 쓰고 유효(Valid), 수정됨(Dirty) 비트를 업데이트해야 한다. 따라서, 캐시는
매 사이클마다 현재 상태와 CPU 요청, 적중 여부, 메모리 신호를 확인하여 필요한 경우
해당 라인의 데이터와 태그를 업데이트한다.

\subsection{LRU 업데이트 및 LRU Way 계산 논리 회로}

\hfill

\begin{longlisting}
    \begin{minted}[fontsize=\footnotesize]{Verilog}
  // Logic that finds the least recently used way in a set 
  always @(*) begin
    lru = 0;
    for (i = 0; i < NUM_WAYS; i = i + 1)
      lru = (lru_bank[index][i] == MAX_LRU) ? i[WAY_INDEX_LEN - 1: 0] : lru;
  end

    ...

      if (state == `IDLE && is_input_valid && is_hit) begin
        for (i = 0; i < NUM_WAYS; i = i + 1) begin
          if (lru_bank[index][i] != MAX_LRU)
            lru_bank[index][i] <= lru_bank[index][i] + 1;
        end
        lru_bank[index][hit_way_index] <= 0;
    \end{minted}
    \caption{LRU Way의 인덱스를 계산하고, LRU 레지스터를 업데이트하는 논리 회로}
\end{longlisting}

\hfill

캐시에서는 요청된 집합의 가장 오래 전에 쓰인 Way(Least Recently Used Way; 이하 
LRU Way로 칭함)를 계산하기 위해, 모든 Way마다 Way가 속한 집합에서의 '순위'를 
저장하는 레지스터, \code{lru_bank}를 가지고 있다. 어떤 Way가 적중할 때마다, 그
Way의 순위는 0으로 재설정되고 해당 집합의 LRU Way를 제외한 나머지 Way들의 순위는 
1씩 늘어난다.

반대로, 요청된 집합의 LRU Way를 찾기 위해, 캐시는 해당 집합의 Way를 모두 순회하여
순위가 \code{MAX_LRU}의 값을 가지는 Way를 찾는다. \code{MAX_LRU}는 
\code{NUM_WAYS - 1}의 값을 가지는 상수로, 어떤 Way의 순위가 \code{MAX_LRU}라는
것은 해당 Way가 LRU Way임을 뜻한다.

쉽게 말해, 영희, 철수, 민수, 길동이 있는 그룹에서 무작위로 한 명씩을 호명한다고
하자. 이때 찾고 싶은 것은 마지막으로 호명된 이후 가장 많은 시간이 지난 사람이다. 
이를 위해 "영희는 1등, 철수는 3등, 민수는 0등, 길동은 2등"과 같은 정보를 
저장해두고, 매 호명마다 호명된 사람은 0등으로, 3등을 제외한 나머지의 등수를 1씩 
올린다. 이후 "호명된 이후 가장 많은 시간이 지난 사람은 누구인가?"와 같은 질의가 
들어오면 현재 3등인 사람을 알려주면 될 것이다. 위 코드는 이와 같은 아이디어를 
구현한다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                    Discussion                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion}

\subsection{직접 사상 캐시와 집합 연관 사상 캐시의 캐시 적중률}

\subsection{교체 정책}

\subsection{캐시를 활용한 행렬곱 연산의 최적화}

\subsection{집합의 수 변화에 따른 캐시 적중률의 차이}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                    Conclusion                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

이번 과제에서는 지난 4-1에 이어 Pipelined CPU의 Control Flow DataPath를 구현하는 것을 목적으로 하여, Pipelined CPU를 완성하였다.
기존 Multi-Cycle CPU와는 달리 Branch Taken/Not Taken 여부와 Branch Instruction 다음 Fetch하는 Instruction의 위치에 따라서 Stall이 발생할 수 있기 때문에, Branch Prediction이 중요하다.
2-Bit Saturation Counter 기반의 2-Bit Global Branch Predictor를 구현하여 기존 Always-Taken, Always-Not-Taken 전략과의 비교할 수 있었지만, 주어진 프로그램에 의존하는 특성상 정확한 비교를 할 수 없어 기대한 결과를 확인하지 못하였다.
Single-Cycle CPU, Multi-Cycle CPU, Pipelined CPU의 발전 동안 Data Memory 관점에서의 개선은 미비하였는데, Data Memory 접근성을 늘릴 수 있는 Cache의 필요성을 확인할 수 있었다.

\end{document}